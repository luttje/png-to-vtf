<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0">
  <title>PNG to VTF Converter - Browser Demo</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #e0e0e0;
    }

    h1 {
      color: #ff6b35;
      text-align: center;
      margin-bottom: 0.5rem;
    }

    .subtitle {
      text-align: center;
      color: #888;
      margin-bottom: 2rem;
    }

    .container {
      background: #1e1e2e;
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .drop-zone {
      border: 3px dashed #444;
      border-radius: 12px;
      padding: 3rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      background: #252535;
    }

    .drop-zone:hover,
    .drop-zone.dragover {
      border-color: #ff6b35;
      background: #2a2a3a;
    }

    .drop-zone-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
    }

    .options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin: 1.5rem 0;
    }

    .option-group {
      background: #252535;
      padding: 1rem;
      border-radius: 8px;
    }

    .option-group label {
      display: block;
      margin-bottom: 0.5rem;
      color: #aaa;
      font-size: 0.875rem;
    }

    select,
    input[type="checkbox"] {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid #444;
      border-radius: 6px;
      background: #1e1e2e;
      color: #e0e0e0;
      font-size: 1rem;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .checkbox-group input[type="checkbox"] {
      width: auto;
    }

    .preview-container {
      display: none;
      margin-top: 2rem;
    }

    .preview-container.active {
      display: block;
    }

    .preview-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
    }

    .preview-box {
      background: #252535;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
    }

    .preview-box h3 {
      margin: 0 0 1rem 0;
      color: #ff6b35;
      font-size: 1rem;
    }

    .preview-box img,
    .preview-box canvas {
      max-width: 100%;
      max-height: 256px;
      border-radius: 4px;
      background: repeating-conic-gradient(#333 0% 25%, #444 0% 50%) 50% / 16px 16px;
    }

    .info {
      margin-top: 1rem;
      font-size: 0.875rem;
      color: #888;
    }

    .btn {
      display: inline-block;
      padding: 0.75rem 1.5rem;
      background: #ff6b35;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.3s;
      text-decoration: none;
    }

    .btn:hover {
      background: #ff8555;
    }

    .btn:disabled {
      background: #555;
      cursor: not-allowed;
    }

    .actions {
      margin-top: 1.5rem;
      text-align: center;
    }

    .status {
      margin-top: 1rem;
      padding: 1rem;
      border-radius: 8px;
      display: none;
    }

    .status.success {
      display: block;
      background: rgba(46, 204, 113, 0.2);
      border: 1px solid #2ecc71;
      color: #2ecc71;
    }

    .status.error {
      display: block;
      background: rgba(231, 76, 60, 0.2);
      border: 1px solid #e74c3c;
      color: #e74c3c;
    }

    footer {
      text-align: center;
      margin-top: 2rem;
      color: #666;
    }

    footer a {
      color: #ff6b35;
    }

    .hidden {
      display: none !important;
    }

    /* Loading overlay */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(26, 26, 46, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .loading-overlay.active {
      display: flex;
    }

    .spinner {
      width: 60px;
      height: 60px;
      border: 4px solid #333;
      border-top-color: #ff6b35;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .loading-text {
      margin-top: 1.5rem;
      color: #ff6b35;
      font-size: 1.1rem;
      font-weight: 500;
    }

    .loading-subtext {
      margin-top: 0.5rem;
      color: #888;
      font-size: 0.9rem;
    }
  </style>
</head>

<body>
  <div class="loading-overlay"
       id="loadingOverlay">
    <div class="spinner"></div>
    <div class="loading-text"
         id="loadingText">Processing...</div>
    <div class="loading-subtext"
         id="loadingSubtext">This may take a moment for large images</div>
  </div>

  <h1>üéÆ PNG to VTF Converter</h1>
  <p class="subtitle">Convert PNG images to Valve Texture Format in your browser</p>

  <div class="container">
    <div class="drop-zone"
         id="dropZone">
      <div class="drop-zone-icon">üìÅ</div>
      <p>Drag & drop a PNG image here<br>or click to select</p>
      <input type="file"
             id="fileInput"
             accept="image/png,image/jpeg,image/webp"
             hidden>
    </div>

    <div class="options">
      <div class="option-group">
        <label for="format">Output Format</label>
        <select id="format">
          <option value="DXT5">DXT5 (Compressed with Alpha)</option>
          <option value="DXT1">DXT1 (Compressed, No Alpha)</option>
          <option value="BGRA8888">BGRA8888 (Uncompressed)</option>
          <option value="RGB888">RGB888 (Uncompressed, No Alpha)</option>
          <option value="BGR888">BGR888 (Uncompressed, No Alpha)</option>
        </select>
        <div class="checkbox-group"
             style="margin-top: 0.75rem;">
          <input type="checkbox"
                 id="mipmaps"
                 checked>
          <label for="mipmaps">Generate Mipmaps</label>
        </div>
      </div>

      <div class="option-group">
        <label for="resize">Resize</label>
        <select id="resize">
          <option value="">Keep Original</option>
          <option value="64">64 √ó 64</option>
          <option value="128">128 √ó 128</option>
          <option value="256">256 √ó 256</option>
          <option value="512">512 √ó 512</option>
          <option value="1024">1024 √ó 1024</option>
          <option value="2048">2048 √ó 2048</option>
        </select>
        <div class="checkbox-group"
             style="margin-top: 0.75rem;">
          <input type="checkbox"
                 id="keepAspect">
          <label for="keepAspect">Keep Aspect Ratio</label>
        </div>
        <div id="alignmentGroup"
             style="margin-top: 0.75rem; display: none;">
          <label for="alignment"
                 style="font-size: 0.8rem;">Alignment</label>
          <select id="alignment">
            <option value="top">Top</option>
            <option value="left">Left</option>
            <option value="center">Center</option>
            <option value="right">Right</option>
            <option value="bottom">Bottom</option>
          </select>
        </div>
      </div>
    </div>

    <div class="preview-container"
         id="previewContainer">
      <div class="preview-grid">
        <div class="preview-box">
          <h3>üì∑ Original Image</h3>
          <img id="originalPreview"
               alt="Original">
          <div class="info"
               id="originalInfo"></div>
        </div>
        <div class="preview-box">
          <h3>üéÆ VTF Preview</h3>
          <canvas id="vtfPreview"></canvas>
          <div class="info"
               id="vtfInfo"></div>
        </div>
      </div>

      <div class="actions">
        <button class="btn"
                id="downloadBtn"
                disabled>‚¨áÔ∏è Download VTF</button>
      </div>

      <div class="status"
           id="status"></div>
    </div>
  </div>

  <footer>
    <p>
      Powered by <a href="https://github.com/luttje/png-to-vtf"
         target="_blank">png-to-vtf</a> |
      Works with Source engine games like Garry's Mod, Counter-Strike, TF2, and Half-Life 2
    </p>
  </footer>

  <script type="module">
    import { convertImageDataToVTF, VTF_FORMATS, VTF_FLAGS } from './png-to-vtf.browser.min.mjs';

    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const previewContainer = document.getElementById('previewContainer');
    const originalPreview = document.getElementById('originalPreview');
    const vtfPreview = document.getElementById('vtfPreview');
    const originalInfo = document.getElementById('originalInfo');
    const vtfInfo = document.getElementById('vtfInfo');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusEl = document.getElementById('status');
    const formatSelect = document.getElementById('format');
    const resizeSelect = document.getElementById('resize');
    const mipmapsCheckbox = document.getElementById('mipmaps');
    const keepAspectCheckbox = document.getElementById('keepAspect');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const loadingText = document.getElementById('loadingText');
    const loadingSubtext = document.getElementById('loadingSubtext');
    const alignmentSelect = document.getElementById('alignment');
    const alignmentGroup = document.getElementById('alignmentGroup');

    let currentFileName = 'texture.vtf';
    let currentImageData = null;

    // Loading overlay helpers
    function showLoading(text = 'Processing...', subtext = 'This may take a moment for large images') {
      loadingText.textContent = text;
      loadingSubtext.textContent = subtext;
      loadingOverlay.classList.add('active');
    }

    function hideLoading() {
      loadingOverlay.classList.remove('active');
    }

    // Drop zone events
    dropZone.addEventListener('click', () => fileInput.click());

    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('dragover');
    });

    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        handleFile(files[0]);
      }
    });

    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        handleFile(e.target.files[0]);
      }
    });

    function updateAlignmentVisibility() {
      if (!currentImageData || !keepAspectCheckbox.checked) {
        alignmentGroup.style.display = 'none';
        return;
      }

      const width = currentImageData.width;
      const height = currentImageData.height;

      if (width === height) {
        // Square image - no alignment needed
        alignmentGroup.style.display = 'none';
      } else if (height > width) {
        // Taller than wide - show horizontal alignment options
        alignmentGroup.style.display = 'block';
        alignmentSelect.innerHTML = `
          <option value="left">Left</option>
          <option value="center" selected>Center</option>
          <option value="right">Right</option>
        `;
      } else {
        // Wider than tall - show vertical alignment options
        alignmentGroup.style.display = 'block';
        alignmentSelect.innerHTML = `
          <option value="top">Top</option>
          <option value="center" selected>Center</option>
          <option value="bottom">Bottom</option>
        `;
      }
    }

    // Update preview when options change
    formatSelect.addEventListener('change', () => updatePreviewWithLoading());
    resizeSelect.addEventListener('change', () => updatePreviewWithLoading());
    mipmapsCheckbox.addEventListener('change', () => updatePreviewWithLoading());
    keepAspectCheckbox.addEventListener('change', async () => {
      updateAlignmentVisibility();
      await updatePreviewWithLoading();
    });
    alignmentSelect.addEventListener('change', () => updatePreviewWithLoading());
    updateAlignmentVisibility();

    async function handleFile(file) {
      showStatus('', '');
      showLoading('Loading image...', 'Please wait');
      await yieldToMain();

      // Store filename for download
      currentFileName = file.name.replace(/\.[^.]+$/, '.vtf');

      // Load image
      const img = new Image();
      img.onload = async () => {
        // Show original preview
        originalPreview.src = img.src;
        originalInfo.textContent = `${img.width} √ó ${img.height} pixels`;

        // Get image data from canvas
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        currentImageData = ctx.getImageData(0, 0, img.width, img.height);

        previewContainer.classList.add('active');
        updateAlignmentVisibility();
        await updatePreview();
        hideLoading();
      };

      img.onerror = () => {
        showStatus('Failed to load image', 'error');
      };

      img.src = URL.createObjectURL(file);
    }

    // Get processed image data based on current settings
    function getProcessedImageData() {
      const resize = resizeSelect.value ? parseInt(resizeSelect.value) : null;

      let imageData = currentImageData;
      let finalWidth = currentImageData.width;
      let finalHeight = currentImageData.height;

      if (resize && (resize !== currentImageData.width || resize !== currentImageData.height)) {
        // Resize using Canvas API
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = currentImageData.width;
        tempCanvas.height = currentImageData.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(currentImageData, 0, 0);

        const resizeCanvas = document.createElement('canvas');
        resizeCanvas.width = resize;
        resizeCanvas.height = resize;
        const resizeCtx = resizeCanvas.getContext('2d');

        // Clear canvas with transparent pixels
        resizeCtx.clearRect(0, 0, resize, resize);

        if (keepAspectCheckbox.checked) {
          // Keep aspect ratio: scale to fit and align based on selection
          const srcWidth = currentImageData.width;
          const srcHeight = currentImageData.height;
          const scale = Math.min(resize / srcWidth, resize / srcHeight);
          const scaledWidth = srcWidth * scale;
          const scaledHeight = srcHeight * scale;

          // Calculate offset based on alignment
          const alignment = alignmentSelect.value;
          let offsetX, offsetY;

          // Horizontal alignment
          if (alignment.includes('left')) {
            offsetX = 0;
          } else if (alignment.includes('right')) {
            offsetX = resize - scaledWidth;
          } else {
            offsetX = (resize - scaledWidth) / 2;
          }

          // Vertical alignment
          if (alignment.includes('top')) {
            offsetY = 0;
          } else if (alignment.includes('bottom')) {
            offsetY = resize - scaledHeight;
          } else {
            offsetY = (resize - scaledHeight) / 2;
          }

          resizeCtx.drawImage(tempCanvas, offsetX, offsetY, scaledWidth, scaledHeight);
        } else {
          // Stretch to fill
          resizeCtx.drawImage(tempCanvas, 0, 0, resize, resize);
        }

        imageData = resizeCtx.getImageData(0, 0, resize, resize);
        finalWidth = resize;
        finalHeight = resize;
      }

      return { imageData, finalWidth, finalHeight };
    }

    // Helper to yield to browser for UI updates - must wait for actual paint
    function yieldToMain() {
      return new Promise(resolve => {
        // requestAnimationFrame schedules for next frame, then setTimeout ensures we're after paint
        requestAnimationFrame(() => {
          setTimeout(resolve, 50);
        });
      });
    }

    async function updatePreviewWithLoading() {
      if (!currentImageData) return;
      showLoading('Updating preview...', 'Processing image');
      await yieldToMain();
      await updatePreview();
      hideLoading();
    }

    async function updatePreview() {
      if (!currentImageData) return;

      const format = formatSelect.value;
      const mipmaps = mipmapsCheckbox.checked;
      const { imageData, finalWidth, finalHeight } = getProcessedImageData();

      // Show VTF info (estimated)
      const mipmapCount = mipmaps ? Math.floor(Math.log2(Math.max(finalWidth, finalHeight))) + 1 : 1;

      vtfInfo.innerHTML = `
        ${finalWidth} √ó ${finalHeight} pixels<br>
        Format: ${format}<br>
        Mipmaps: ${mipmapCount}
      `;

      // Draw preview using the processed image data
      const ctx = vtfPreview.getContext('2d');

      // Scale preview to fit within 256x256
      const scale = Math.min(256 / finalWidth, 256 / finalHeight, 1);
      const previewWidth = finalWidth * scale;
      const previewHeight = finalHeight * scale;
      vtfPreview.width = previewWidth;
      vtfPreview.height = previewHeight;

      // Draw the processed image
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = imageData.width;
      tempCanvas.height = imageData.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.putImageData(imageData, 0, 0);

      ctx.drawImage(tempCanvas, 0, 0, previewWidth, previewHeight);

      downloadBtn.disabled = false;
      showStatus('', '');
    }

    downloadBtn.addEventListener('click', async () => {
      if (!currentImageData) return;

      showLoading('Converting to VTF...', 'Please wait');

      // Defer to allow UI to paint the loading overlay
      await yieldToMain();

      try {
        const format = formatSelect.value;
        const mipmaps = mipmapsCheckbox.checked;
        const { imageData } = getProcessedImageData();

        // Prepare options
        const options = {
          format: VTF_FORMATS[format],
          generateMips: mipmaps,
        };

        if (!mipmaps) {
          options.flags = VTF_FLAGS.NOMIP;
        }

        // Convert using browser-compatible API
        const vtfBuffer = convertImageDataToVTF(imageData, options);

        // Download immediately
        const blob = new Blob([vtfBuffer], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = currentFileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        hideLoading();
        showStatus(`‚úÖ Downloaded ${currentFileName} (${(vtfBuffer.byteLength / 1024).toFixed(1)} KB)`, 'success');

      } catch (error) {
        hideLoading();
        console.error('Conversion error:', error);
        showStatus(`‚ùå Error: ${error.message}`, 'error');
      }
    });

    function showStatus(message, type) {
      statusEl.textContent = message;
      statusEl.className = 'status';
      if (type) {
        statusEl.classList.add(type);
      }
    }
  </script>
</body>

</html>